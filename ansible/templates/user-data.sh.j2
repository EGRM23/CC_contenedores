#!/bin/bash
set -x

yum update -y

yum install docker git stress-ng -y

systemctl start docker
systemctl enable docker
usermod -a -G docker ec2-user

# curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
# install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

# # Instalar k3s (Kubernetes lightweight)
# export INSTALL_K3S_EXEC="--write-kubeconfig-mode=644"
# curl -sfL https://get.k3s.io | sh -

# # Configurar variables de entorno
# export KUBECONFIG=/etc/rancher/k3s/k3s.yaml

# # Esperar a que k3s estÃ© listo
# echo "â³ Esperando a que k3s estÃ© listo..."
# for i in {1..30}; do
#     if kubectl get nodes 2>/dev/null; then
#         echo "âœ… k3s estÃ¡ listo!"
#         break
#     fi
#     echo "â±ï¸ Intento $i/30 - Esperando k3s..."
#     sleep 10
# done

# # Configurar kubectl para el usuario ec2-user
# mkdir -p /home/ec2-user/.kube
# cp /etc/rancher/k3s/k3s.yaml /home/ec2-user/.kube/config
# chown -R ec2-user:ec2-user /home/ec2-user/.kube

cd /home/ec2-user
git clone {{ git_repo }}
chown -R ec2-user:ec2-user CC-Contenedores

cd CC-Contenedores

echo "ğŸ³ Construyendo imagen del la app..."
docker build -t cc_contenedores-backend:latest ./backend
docker build -t cc_contenedores-frontend:latest ./frontend
docker build -t cc_contenedores-db:latest ./db

# echo "ğŸ“¥ Importando imÃ¡genes en k3s..."
# docker save cc_contenedores-backend:latest | sudo k3s ctr images import - || echo "âš ï¸  Error importando backend, continuando..."
# docker save cc_contenedores-frontend:latest | sudo k3s ctr images import - || echo "âš ï¸  Error importando frontend, continuando..."
# docker save cc_contenedores-db:latest | sudo k3s ctr images import - || echo "âš ï¸  Error importando db, continuando..."

# # Listar imÃ¡genes en k3s para verificar
# echo "ğŸ“‹ ImÃ¡genes disponibles en k3s:"
# sudo k3s ctr images list | grep cc_contenedores || echo "âŒ No se encontraron imÃ¡genes cc_contenedores"

# # Ejecutar el script de despliegue original (que ahora aplicarÃ¡ los HPA)
# echo "ğŸš€ Ejecutando deploy.sh original..."
# chmod +x deploy.sh

# # Verificar si el deploy.sh incluye los HPA, si no, los aplicamos despuÃ©s
# if grep -q "hpa" deploy.sh || grep -q "autoscaling" deploy.sh; then
#     echo "âœ… deploy.sh incluye HPA, ejecutando normalmente..."
#     sudo -u ec2-user ./deploy.sh
# else
#     echo "âš ï¸  deploy.sh no incluye HPA, ejecutando y luego aplicando HPA..."
#     sudo -u ec2-user ./deploy.sh
    
#     # Aplicar los HPA desde tus archivos
#     echo "ğŸ“ˆ Aplicando HPA desde archivos YAML..."
#     sudo -u ec2-user kubectl apply -f k8s/backend-hpa.yaml
#     sudo -u ec2-user kubectl apply -f k8s/frontend-hpa.yaml
# fi

# # Verificar el despliegue
# echo "ğŸ“Š Verificando despliegue..."
# sudo -u ec2-user kubectl get pods
# sudo -u ec2-user kubectl get hpa

docker run -d --name database -p 5432:5432 db:latest
docker run -d --name backend -p 3000:3000 --link database:database backend:latest
docker run -d --name frontend -p 80:80 --link backend:backend frontend:latest

# InformaciÃ³n de acceso
PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)

echo "ğŸ‰ APLICACIÃ“N DESPLEGADA!"
echo "ğŸŒ Frontend: http://$PUBLIC_IP"
echo "ğŸ”— Backend: http://$PUBLIC_IP:3000"
echo "ğŸ“Š Para probar carga: stress-ng --cpu 2 --timeout 60"